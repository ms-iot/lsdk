# Enabling Secure Boot

Secure boot is required to boot the platform into the secure/trusted state, which enables access to the device's secret identity.

Additional documentation for LS1012a secure boot:
* The [LS1012A Reference Manual](https://www.nxp.com/products/processors-and-microcontrollers/arm-based-processors-and-mcus/qoriq-layerscape-arm-processors/qoriq-layerscape-1012a-low-power-communication-processor:LS1012A?tab=Documentation_Tab) specifies the fusing process and security registers.
* NXP document [AN5227](https://www.nxp.com/docs/en/application-note/AN5227.pdf?&fasp=1) is an end to end walkthrough for using NXP's CodeWarrior debugger to fuse a platform for secure boot.
* The [Layerscape SDK 18.09 Documentation](https://nxp.sdlproducts.com/LiveContent/web/pub.xql?c=t&action=home&pub=QorIQ_LSDK_18.09&lang=en-US) contains detailed information about the Layerscape secure boot flow and error conditions.

The LS1012a has two options for enabling secure boot:
1. Setting the SB_EN bit in the RCW
	* This will boot the platform into a trusted state if the SPL signature is correct. An invalid image signature will not halt boot but instead continue with the platform in the non-secure state, disabling access to the secret device identity.
1. Blowing the Intent To Secure (ITS) fuse.
	* This is **not recommended** during development on the Grapeboard because it will prevent boot for the push-button recovery firmware.

## Environment Setup
NXP's QorIQ Code Signing Tool (CST) is used to generate OTPMKs, create public/private key pairs, and sign firmware for secure boot. CST is built automatically by LSDK and placed in `lsdk/packages/apps/cst` but you can also build it standalone:

```bash
git clone -b LSDK-18.09 https://source.codeaurora.org/external/qoriq/qoriq-components/cst/
cd cst
make
```

The important CST apps for secure boot are gen_keys, uni_sign, and gen_otpmk_drbg.

## Fuse Prerequisites
To secure boot both OTPMK and SRKH must be fused on the platform.

### OTPMK
The One Time Programmable Master Key is the basis of the platform's secret identity and must be burned into the Security Fuse Processor (SFP).

Check the OTPMK_ZERO bit of the SecMon_HP Status Register (HPSR), if the bit is 1 the OTPMK has not been provisioned.

When generating a new OTPMK it must have an embedded Hamming code because the SFP hides the value of the OTPMK in the mirror registers even before the fuses are blown. The Hamming code allows the Secret Value Hamming Error Status Register (SFP_SVHESR) to report any errors with the intended OTPMK before the fuses are blown. If SFP_SVHESR reads zero then the OTPMK is valid.

**Each platform must have its own OTPMK value, you must run gen_otpmk_drbg from CST yourself to create a unique key**
```bash
qoriq_cst/cst$ ./gen_otpmk_drbg -b 2

#----------------------------------------------------#
#-------         --------     --------        -------#
#------- CST (Code Signing Tool) Version 2.0  -------#
#-------         --------     --------        -------#
#----------------------------------------------------#

Input string not provided
Generating a random string
-------------------------------------------
* Hash_DRBG library invoked
* Seed being taken from /dev/random
-------------------------------------------
OTPMK[255:0] is:
1970927c020de4cbbfc0330f32585f5f2b40b3abcae88649b881f6f997230931

 NAME    |     BITS     |    VALUE
_________|______________|____________
OTPMKR 0 | 255-224      |   1970927c
OTPMKR 1 | 223-192      |   020de4cb
OTPMKR 2 | 191-160      |   bfc0330f
OTPMKR 3 | 159-128      |   32585f5f
OTPMKR 4 | 127- 96      |   2b40b3ab
OTPMKR 5 |  95- 64      |   cae88649
OTPMKR 6 |  63- 32      |   b881f6f9
OTPMKR 7 |  31-  0      |   XXXXXXXX
```

The resulting OTPMKR values must be written into the corresponding SFP_OTPMKRn registers in the SFP. When the whole OTPMK is written, and both the HPSR and SFP_SVHESR show no errors, the fuses may be blown to persist the OTPMK value across reset.

### SRKH
The Super Root Key Hash is used to verify the Command Sequence File (CSF). The CSF is used to verify the signature of the SPL image loaded into OCRAM on boot.

This value is to be shared across multiple devices so they can all boot the same secure boot enabled firmware.

To determine the SRKH value for your platform, first you must sign a binary with the keypair generated by gen_keys in CST.

```bash
qoriq_cst/cst$ ./gen_keys 1024

#----------------------------------------------------#
#-------         --------     --------        -------#
#------- CST (Code Signing Tool) Version 2.0  -------#
#-------         --------     --------        -------#
#----------------------------------------------------#

===============================================================
This product includes software developed by the OpenSSL Project
for use in the OpenSSL Toolkit (http://www.openssl.org/)
This product includes cryptographic software written by
Eric Young (eay@cryptsoft.com)
===============================================================

Generated SRK pair stored in :

PUBLIC KEY srk.pub

PRIVATE KEY srk.pri
```

**For secure boot compatibility with other developers you can use the pre-generated srk.pub and srk.pri keypair checked into this repository in [tools/secureboot/](tools/secureboot/)**

1. Copy srk.pri, srk.pub, and input_spl_secure from lsdk/tools/secureboot into your CST directory
1. Copy spl/u-boot-spl.bin from your u-boot repo into your CST directory
1. Run uni_sign on input_spl_secure to sign u-boot-spl and show the SRKH for srk.pri/srk.pub
    ```bash
    qoriq_cst/cst$ ./uni_sign input_spl_secure
    #----------------------------------------------------#
    #-------         --------     --------        -------#
    #------- CST (Code Signing Tool) Version 2.0  -------#
    #-------         --------     --------        -------#
    #----------------------------------------------------#
    
    ==========================================================
    This tool includes software developed by OpenSSL Project
    for use in the OpenSSL Toolkit (http://www.openssl.org/)
    This product includes cryptographic software written by
    Eric Young (eay@cryptsoft.com)
    ==========================================================
    
    Input File is input_spl_secure
    
    ************************************************
    * Header File is with Signature appended
    ************************************************
    
    Header File Created: hdr_spl.out
    
    SRK (Public Key) Hash:
    c5c9bdd14798424d5196bb6cb0c5f1509abbddf92c3ae57b72e8222c4c37a543
    SFP SRKHR0 = c5c9bdd1
    SFP SRKHR1 = 4798424d
    SFP SRKHR2 = 5196bb6c
    SFP SRKHR3 = b0c5f150
    SFP SRKHR4 = 9abbddf9
    SFP SRKHR5 = 2c3ae57b
    SFP SRKHR6 = 72e8222c
    SFP SRKHR7 = 4c37a543
    ```

You can verify SRKH before blowing the fuses by adding boot hold off to the RCW then setting a temporary SRKH in the SFP registers using [NXP's CodeWarrior](https://www.nxp.com/support/developer-resources/software-development-tools/codewarrior-development-tools/codewarrior-network-applications:CW_SUITES_NETAPPS) and [AN5227](https://www.nxp.com/docs/en/application-note/AN5227.pdf?&fasp=1) at the start of boot. To configure U-Boot for boot hold off edit `rcw_secureboot.cfg` and change the value on line 9 from
`40200000` to `40600000`

Ensure that these values are programmed into the SRKH fuses as big endian, fusing the SRKH incorrectly will make it impossible to ever secure boot the platform.

Below are the Trace32 commands for fusing the SRKH for the included srk.pri/srk.pub. Verify the values in the SFP registers before blowing the fuses.
```
D.S MD:0x1E80254 %BE %Long 0xc5c9bdd1
D.S MD:0x1E80258 %BE %Long 0x4798424d
D.S MD:0x1E8025C %BE %Long 0x5196bb6c
D.S MD:0x1E80260 %BE %Long 0xb0c5f150
D.S MD:0x1E80264 %BE %Long 0x9abbddf9
D.S MD:0x1E80268 %BE %Long 0x2c3ae57b
D.S MD:0x1E8026C %BE %Long 0x72e8222c
D.S MD:0x1E80270 %BE %Long 0x4c37a543

# While holding the PROG_SFP input of the SoC at 1.8V run the following to make SFP blow the fuses
D.S MD:0x1E80020 %LE %Long 0x02000000
```

# Building and signing SPL for Secure Boot

1. Run the following in your U-Boot directory to build an image with secure boot enabled in the Reset Control Word.
    ```bash
    make grapeboard_pcie_qspi_spl_secureboot_defconfig
    make
    ```

2. Copy spl/u-boot-spl.bin from your u-boot repo into your CST directory
3. Run `./uni_sign input_spl_secure` to sign u-boot-spl and generate hdr_spl.out
	* hdr_spl.out is the CSF file that will match with the SRKH fused into your board then verify the integrity of the SPL built into u-boot-with-spl-pbl.bin
4. Copy hdr_spl.out from cst and u-boot-with-spl-pbl.bin from u-boot onto your SD card
5. From the U-Boot prompt on your Grapeboard run the following command to apply the signed firmware to your flash memory:
    ```
    mmc rescan
    fatload mmc 0:1 $load_addr u-boot-with-spl-pbl.bin
    sf probe 0:0
    sf erase u-boot 200000
    sf write $load_addr u-boot $filesize
    fatload mmc 0:1 $load_addr hdr_spl.out
    sf probe 0:0
    sf erase u-boot_hdr 40000
    sf write $load_addr u-boot_hdr $filesize
    ```
6. Reset the platform and it should attempt secure boot. If the device secure booted successfully you **will not see** the following in your SPL boot log:
    ```
    SSM not in secure/trusted state
    Security state failure
    Continuing with non-secret testing identity
    ```

If the device did not boot or is not in the secure/trusted state you can check the value in SCRATCHRW2 in the DCFG_CCSR block to find the secure boot failure code.
